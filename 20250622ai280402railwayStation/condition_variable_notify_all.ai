/*
Директива #include <condition_variable> в C++ подключает заголовочный файл, который предоставляет класс std::condition_variable. 
Этот класс является примитивом синхронизации, используемым в многопоточном программировании для ожидания 
и уведомления о наступлении определенного условия. 
Он работает в паре с мьютексом (std::mutex) и позволяет потокам ждать, 
пока не будет выполнено какое-то условие, а затем получать уведомление об этом. 
Что такое std::condition_variable?
std::condition_variable позволяет потокам "спать" (ожидать) до тех пор, пока не будет получено уведомление о том, 
что определенное условие стало истинным. 
Это полезно, когда один поток может изменять общее состояние (например, данные, к которым обращаются несколько потоков), 
а другой поток должен знать, когда это состояние изменилось, чтобы предпринять какие-то действия. 
Как это работает?

    1. Блокировка мьютекса:
    Прежде чем поток может ждать на условной переменной, он должен заблокировать мьютекс, 
    который используется для защиты общего состояния, которое будет изменено.
    2. Ожидание:
    Поток вызывает wait() на std::condition_variable. Эта операция автоматически разблокирует мьютекс и переводит поток в режим ожидания. 
    Поток останется в режиме ожидания, пока не получит уведомление.
    3. Уведомление:
    Когда другой поток изменяет общее состояние и решает, что условие выполнено, он вызывает notify_one() или notify_all() на std::condition_variable. 
    Это разбудит один или все потоки, ожидающие на этой условной переменной, соответственно.
    4. Продолжение работы:
    После получения уведомления поток, ожидающий на условной переменной, автоматически повторно заблокирует мьютекс и продолжит работу. 

В заключение, #include <condition_variable> предоставляет инструменты для создания сложных многопоточных приложений, 
где потоки могут синхронизироваться и обмениваться данными, используя условные переменные и мьютексы. 


==========================================================================================

методы condition_variable c++
Методы класса std::condition_variable в C++ обеспечивают механизм синхронизации потоков, 
позволяя потокам ожидать наступления определенного условия и уведомлять другие потоки об этом событии. 
Основные методы: wait(), wait_for(), wait_until(), notify_one(), и notify_all(). 
Подробное описание методов:

    wait(std::unique_lock<std::mutex>& lock):
        Блокирует текущий поток, пока не будет вызван метод notify_one() или notify_all(). 

Освобождает предоставленный мьютекс lock при блокировке и повторно захватывает его при пробуждении. 
Обязательно должен использоваться с объектом std::unique_lock, который уже захватил мьютекс. 

wait_for(std::unique_lock<std::mutex>& lock, const std::chrono::duration<Rep, Period>& rel_time):

    Блокирует текущий поток на заданное время rel_time. 

Освобождает предоставленный мьютекс lock при блокировке и повторно захватывает его при пробуждении или истечении времени ожидания. 
Поток может быть разблокирован до истечения времени ожидания, если будет вызван метод notify_one() или notify_all(). 

wait_until(std::unique_lock<std::mutex>& lock, const std::chrono::time_point<Clock, Duration>& abs_time):

    Блокирует текущий поток до указанного момента времени abs_time. 

Освобождает предоставленный мьютекс lock при блокировке и повторно захватывает его при пробуждении или наступлении указанного времени. 
Поток может быть разблокирован до истечения времени ожидания, если будет вызван метод notify_one() или notify_all(). 

notify_one():

    Разблокирует один из потоков, ожидающих на данном condition_variable. 

Если нет ожидающих потоков, то метод ничего не делает. 

notify_all():

    Разблокирует все потоки, ожидающие на данном condition_variable. 

Если нет ожидающих потоков, то метод ничего не делает. 

Важно:

    condition_variable всегда используется в паре с std::mutex для защиты общего состояния, которое проверяется в условном выражении. 

Перед вызовом wait(), wait_for() или wait_until() необходимо сначала захватить мьютекс с помощью std::unique_lock. 
condition_variable может быть разбужен как ложно (spurious wakeups), поэтому всегда следует проверять условие после пробуждения из функции ожидания. 

В целом, condition_variable предоставляет гибкий и мощный механизм для координации выполнения потоков в C++, 
позволяя им ожидать наступления определенных условий и синхронизировать доступ к общим ресурсам. 

===============================================================================================================

что подключается #include <condition_variable> C++ и что за метод notify_all

Обзор от ИИ Директива #include <condition_variable> в C++ подключает заголовочный файл, содержащий 
определение класса std::condition_variable. Этот класс предоставляет механизм синхронизации, 
позволяющий потокам ждать определенных условий, и сигнализировать о наступлении этих условий 
другим потокам. Метод notify_all() условной переменной пробуждает все потоки, которые в данный 
момент ожидают на этой условной переменной. Объяснение:

    1. #include <condition_variable>: Подключение этого заголовочного файла необходимо для 
    использования класса std::condition_variable. Этот класс предоставляет средства для реализации 
    паттерна "Производитель-Потребитель" и других сценариев, где потокам нужно ждать наступления 
    определенных условий, прежде чем продолжить работу.

2. std::condition_variable: Этот класс является примитивом синхронизации, который работает в 
связке с std::mutex (обычно через std::unique_lock ). Он позволяет потокам ждать, пока не будет 
выполнено определенное условие, и сигнализировать об изменении этого условия другим потокам. 3. 
notify_all(): Этот метод класса std::condition_variable предназначен для пробуждения всех потоков, 
которые в данный момент ожидают на данной условной переменной. Когда вызывается notify_all(), все 
потоки, ожидающие на данной условной переменной, будут разблокированы и смогут продолжить свою 
работу, если условие, которое они ждут, выполнено. В отличие от notify_one(), которая пробуждает 
только один ожидающий поток, notify_all() пробуждает все потоки.

Взаимодействие с std::mutex: Условные переменные всегда используются в паре с мьютексами для 
защиты состояния, которое может меняться. Поток, который хочет дождаться условия, сначала 
блокирует мьютекс, проверяет условие, и если условие не выполнено, ожидает на условной переменной, 
освобождая при этом мьютекс. Когда другой поток сигнализирует об изменении условия, он блокирует 
мьютекс, изменяет состояние, а затем вызывает notify_all() (или notify_one()), чтобы разбудить 
ожидающий поток. Пример: C++

#include <iostream> include <thread> include <mutex> include <condition_variable>

std::mutex mtx; std::condition_variable cv; bool data_ready = false; int result;

void worker_thread() { std::unique_lock<std::mutex> lock(mtx); cv.wait(lock, []{ return 
    data_ready; }); // Ждать, пока data_ready станет true

    std::cout << "Worker thread: Result is " << result << std::endl;
}

void producer_thread() { {
        std::lock_guard<std::mutex> lock(mtx);
        // Подготовка данных
        result = 42; data_ready = true;
    }
    cv.notify_all(); // Пробудить все ожидающие потоки
}

int main() { std::thread worker(worker_thread); std::thread producer(producer_thread);

    producer.join(); worker.join();

    return 0;
}

В этом примере worker_thread ожидает, пока data_ready не станет true. producer_thread 
подготавливает данные, устанавливает data_ready в true и вызывает notify_all() для пробуждения 
worker_thread. 

======================================= 

класс std::condition_variable метод wait 
Обзор от ИИ Метод wait класса std::condition_variable в C++ используется для блокировки текущего 
потока до тех пор, пока не будет получено уведомление от другого потока через связанную с ним 
условную переменную или не произойдет ложное пробуждение. Он работает в паре с std::mutex, который 
должен быть заблокирован до вызова wait и освобождается атомарно при блокировке потока. Подробнее:

    Назначение: std::condition_variable::wait предназначен для синхронизации потоков, когда один 
    поток ожидает наступления определенного условия, а другой поток сигнализирует об изменении 
    этого условия.

Взаимодействие с std::mutex: wait всегда вызывается с заблокированным std::mutex. Он атомарно 
освобождает этот мьютекс и переводит текущий поток в состояние ожидания (блокируется). Когда 
другой поток вызывает notify_one или notify_all на той же условной переменной, один или все 
ожидающие потоки пробуждаются. После пробуждения поток повторно захватывает мьютекс, прежде чем 
продолжить выполнение. Ложные пробуждения: Несмотря на то, что wait обычно пробуждается после 
получения уведомления, могут происходить и ложные пробуждения, когда поток пробуждается без явного 
уведомления. Поэтому рекомендуется всегда использовать wait в цикле с проверкой условия, которое 
ожидается, чтобы убедиться, что оно действительно выполнено после пробуждения. Перегрузки: У wait 
есть несколько перегрузок:

    wait(lock): Ожидает уведомления, используя предоставленный std::unique_lock (или 
    std::lock_guard). Мьютекс должен быть заблокирован до вызова.

wait(lock, predicate): Ожидает уведомления, но также принимает предикат (функцию, возвращающую 
bool). Поток продолжает ожидание, пока предикат не вернет true, и после пробуждения проверяет, что 
предикат все еще true. wait_for(lock, rel_time, predicate): Ожидает в течение заданного интервала 
времени rel_time. wait_until(lock, abs_time, predicate): Ожидает до определенной абсолютной точки 
во времени.

Пример использования:

C++

#include <iostream> include <thread> include <mutex> include <condition_variable>

std::condition_variable cv; std::mutex m; bool data_ready = false;

void worker_thread() { std::unique_lock<std::mutex> lock(m); cv.wait(lock, []{ return data_ready; 
    }); // Ожидание пока data_ready == true std::cout << "Worker thread: data is ready!" << 
    std::endl;
}

int main() { std::thread worker(worker_thread);

    { std::lock_guard<std::mutex> lock(m);
        // Имитация обработки данных
        std::this_thread::sleep_for(std::chrono::seconds(2)); data_ready = true; std::cout << 
        "Main thread: Data is ready, notifying worker thread." << std::endl;
    }
    cv.notify_one(); // Уведомление одного ожидающего потока

    worker.join(); return 0;
}
======================================================================

*/

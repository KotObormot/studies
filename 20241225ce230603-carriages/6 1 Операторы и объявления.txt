statement expression
6.1 Statements and Declarations in Expressions
https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs
6.1 Операторы и объявления в выражениях
Составной оператор, заключенный в скобки, может отображаться как выражение в GNU C. Это позволяет использовать циклы, переключатели и локальные переменные внутри выражения.

Напомним, что составной оператор — это последовательность операторов, заключенных в фигурные скобки; в этой конструкции скобки обрамляют фигурные скобки. Например:
	({ int y = foo (); 
	   int z;
	   if (y > 0) z = y;
	   else z = - y;
	   z; })
является допустимым (хотя и немного более сложным, чем необходимо) выражением для абсолютного значения foo ().
Последним в составном операторе должно быть выражение, за которым следует точка с запятой; значение этого подвыражения служит значением всей конструкции. (Если вы используете какой-либо другой тип оператора последним в фигурных скобках, конструкция имеет тип void, и, таким образом, фактически не имеет значения.)

Эта функция особенно полезна для того, чтобы сделать макроопределения «безопасными» (чтобы они оценивали каждый операнд ровно один раз). Например, функция «максимум» обычно определяется как макрос в стандартном C следующим образом:
	#define max(a,b) ((a) > (b) ? (a) : (b))
Но это определение вычисляет либо a, либо b дважды, с плохими результатами, если операнд имеет побочные эффекты. В GNU C, если вы знаете тип операндов (здесь взят int), вы можете избежать этой проблемы, определив макрос следующим образом:
#define maxint(a,b) \
  	({int _a = (a), _b = (b); _a > _b ? _a : _b; })
 
Обратите внимание, что введение объявлений переменных (как мы делаем в maxint) может привести к затенению переменных, поэтому, хотя этот пример использования макроса max дает правильные результаты:
int _a = 1, _b = 2, c;
c = max (_a, _b);
этот пример с использованием maxint не будет:
	int _a = 1, _b = 2, c;
	c = maxint (_a, _b);
Такая проблема может возникнуть, например, когда мы используем этот шаблон рекурсивно, например, так:
	#define maxint3(a, b, c) \
  ({int _a = (a), _b = (b), _c = (c); maxint (maxint (_a, _b), _c); })
  
Встроенные операторы не допускаются в константных выражениях, таких как значение константы перечисления, ширина битового поля или начальное значение статической переменной.

Если вы не знаете тип операнда, вы все равно можете это сделать, но вы должны использовать typeof или __auto_type (см. Ссылка на тип с помощью typeof).

В G++ результирующее значение выражения оператора подвергается распаду массива и указателя функции и возвращается по значению во включающее выражение. Например, если A является классом, то
 	A a;
        ({a;}).Foo ()
создает временный объект A для хранения результата выражения оператора, который используется для вызова Foo. Поэтому указатель this, наблюдаемый Foo, не является адресом a.

В выражении оператора любые временные объекты, созданные в операторе, уничтожаются в конце этого оператора. Это делает выражения операторов внутри макросов немного отличными от вызовов функций. В последнем случае временные объекты, введенные во время оценки аргумента, уничтожаются в конце оператора, который включает вызов функции. В случае выражения оператора они уничтожаются во время выражения оператора. Например,
	#define macro(a)  ({__typeof__(a) b = (a); b + 3; })
	template<typename T> T function(T a) { T b = a; return b + 3; }
	void foo ()
	{
	  macro (X ());
	  function (X ());
	}
имеет разные места, где уничтожаются временные объекты. В случае макроса временный объект X уничтожается сразу после инициализации b. В случае функции этот временный объект уничтожается при возврате функции.

Эти соображения означают, что, вероятно, плохая идея использовать выражения операторов этой формы в заголовочных файлах, которые предназначены для работы с C++. (Обратите внимание, что некоторые версии библиотеки GNU C содержали заголовочные файлы, использующие выражения операторов, которые приводят именно к этой ошибке.)

Переход в выражение оператора с помощью goto или использование оператора switch вне выражения оператора с меткой case или default внутри выражения оператора не допускается. Переход в выражение оператора с помощью вычисляемого goto (см. Метки как значения) имеет неопределенное поведение. Переход из выражения оператора разрешен, но если выражение оператора является частью более крупного выражения, то не указано, какие другие подвыражения этого выражения были вычислены, за исключением случаев, когда определение языка требует, чтобы определенные подвыражения были вычислены до или после выражения оператора. Оператор break или continue внутри выражения оператора, используемого в while, do или for loop или switch statement condition или for statement init или increment expressions, переходит к внешнему циклу или switch statement, если таковые имеются (иначе это ошибка), а не к циклу или switch statement, в условии или выражении init или increment которого он появляется. В любом случае, как и в случае вызова функции, оценка выражения оператора не перемежается с оценкой других частей содержащего его выражения. Например,
	foo (), (({ bar1 (); goto a; 0; }) + bar2 ()), baz();
вызывает foo и bar1 и не вызывает baz, но может вызывать или не вызывать bar2. Если вызывается bar2, он вызывается после foo и перед bar1.
